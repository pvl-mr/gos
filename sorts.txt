============Быстрая сортировка===============
Данный код реализует алгоритм быстрой сортировки (quick sort) для массива целых чисел. 
Он работает рекурсивно: сначала выбирается опорный элемент (pivot), затем элементы массива распределяются вокруг него таким образом, 
чтобы все элементы, меньшие опорного, находились слева от него, а все элементы, большие опорного - справа. 
Затем рекурсивно вызывается функция для левой и правой частей массива.

Функция partition() отвечает за распределение элементов вокруг опорного элемента. 
Она проходит по массиву слева направо и меняет местами элементы, которые меньше опорного, с элементами, которые больше опорного.
В конце она меняет местами опорный элемент и первый элемент, который больше его.

Функция swap() просто меняет местами два элемента массива.

Алгоритм быстрой сортировки (Quick Sort) работает следующим образом:

1. Выбирается опорный элемент из массива. Обычно выбирают первый или последний элемент, но также можно выбирать случайный элемент.
2. Массив разбивается на две части: элементы, меньшие опорного, и элементы, большие опорного.
3. Рекурсивно применяется алгоритм быстрой сортировки к каждой из двух частей массива.
4. Результатом является объединение отсортированных частей массива и опорного элемента.

Алгоритм быстрой сортировки имеет сложность O(n log n) в среднем случае 
и O(n^2) в худшем случае, когда массив уже отсортирован или содержит множество повторяющихся элементов. 
Однако, благодаря своей эффективности, он широко используется в различных приложениях и является одним из самых популярных алгоритмов сортировки.

=======Сортировка слиянием======================
Данный код реализует алгоритм сортировки слиянием (merge sort) для массива целых чисел. 
Он работает рекурсивно: сначала массив разбивается на две равные части, затем каждая из них сортируется рекурсивно,
а затем объединяются в отсортированный массив.

Функция merge() отвечает за объединение двух отсортированных частей массива в один отсортированный массив. 
Она создает временный массив и последовательно сравнивает элементы из левой и правой частей, записывая меньший элемент во временный массив.
Затем она копирует оставшиеся элементы из левой или правой частей во временный массив и копирует его обратно в исходный массив.

Алгоритм сортировки слиянием (Merge Sort) работает следующим образом:

1. Разбивается исходный массив на две равные части.
2. Рекурсивно применяется алгоритм сортировки слиянием к каждой из двух частей массива.
3. Когда обе части массива отсортированы, они сливаются в один отсортированный массив. Для этого создается временный массив, в который поочередно добавляются элементы из каждой из двух отсортированных частей в порядке возрастания.
4. Результатом является отсортированный массив.

Алгоритм сортировки слиянием имеет сложность O(n log n) в любом случае, что делает его одним из самых эффективных алгоритмов сортировки. 
Он также устойчив к повторяющимся элементам и не зависит от начального порядка элементов в массиве. 
Недостатком алгоритма является необходимость дополнительной памяти для временного массива при слиянии двух частей.

===========Сортировка подсчётом==================
Данный код реализует алгоритм сортировки подсчетом (counting sort) для массива целых чисел.
Он работает следующим образом: сначала создается массив counts, 
в котором для каждого значения из заданного диапазона [0, maxVal] подсчитывается количество его вхождений в исходный массив.
Затем элементы исходного массива перезаписываются в порядке возрастания, соответствующему количеству их вхождений в массив counts.

Алгоритм сортировки подсчетом (Counting Sort) работает следующим образом:

1. Находим максимальное и минимальное значения в исходном массиве.
2. Создаем массив-счетчик размером от минимального до максимального значения и заполняем его нулями.
3. Проходим по исходному массиву и увеличиваем значение соответствующего элемента в массиве-счетчике на 1.
4. Суммируем значения в массиве-счетчике, начиная с первого элемента, чтобы получить позицию каждого элемента в отсортированном массиве.
5. Создаем новый массив равный размеру исходного массива и заполняем его элементами из исходного массива, используя позиции из массива-счетчика.
6. Результатом является отсортированный массив.

Алгоритм сортировки подсчетом имеет сложность O(n + k), где n - количество элементов в исходном массиве, 
а k - диапазон значений в исходном массиве. Он эффективен при работе с большими диапазонами значений, но требует дополнительной памяти для массива-счетчика. 
Алгоритм также не является устойчивым к повторяющимся элементам и не подходит для сортировки объектов или строк.

==========Подразрядная сортировка=============
Данный код реализует алгоритм поразрядной сортировки (radix sort) для массива целых чисел. 
Он работает следующим образом: на каждой итерации цикла for по разрядам чисел создается массив counts, 
в котором для каждой цифры от 0 до 9 подсчитывается количество ее вхождений в числа исходного массива, соответствующих данному разряду. 
Затем массив counts преобразуется так, чтобы каждый элемент содержал сумму значений всех предыдущих элементов. 
Это нужно для того, чтобы на следующем шаге можно было правильно расположить числа в порядке возрастания по данному разряду.
Далее создается временный массив output, в который элементы исходного массива перезаписываются в порядке возрастания по данному разряду. 
Наконец, отсортированный массив output копируется обратно в исходный массив arr.

Алгоритм подразрядной сортировки (Radix Sort) работает следующим образом:

1. Определяем максимальное количество цифр в числах исходного массива.
2. Для каждой цифры, начиная с младшей, выполняем следующие действия:
   - Создаем 10 корзин (от 0 до 9) для разделения чисел по соответствующей цифре.
   - Размещаем каждое число из исходного массива в соответствующей корзине на основе значения цифры.
   - Собираем числа из корзин в порядке от 0 до 9 и помещаем их обратно в исходный массив.
3. Результатом является отсортированный массив.

Алгоритм подразрядной сортировки имеет сложность O(n * k), где n - количество элементов в исходном массиве, 
а k - максимальное количество цифр в числах. Он эффективен при работе с большими числами, но может потребовать дополнительной памяти для создания корзин. 
Алгоритм является устойчивым к повторяющимся элементам и подходит для сортировки объектов и строк, если они могут быть преобразованы в числа.

============Сортировка пузырьком================
Алгоритм пузырьковой сортировки (Bubble Sort) работает следующим образом:

1. Проходим по массиву от начала до конца.
2. Сравниваем каждую пару соседних элементов и, если они находятся в неправильном порядке, меняем их местами.
3. Продолжаем проходить по массиву, пока не будет выполнено n-1 проходов, где n - количество элементов в массиве.
4. Результатом является отсортированный массив.

Алгоритм пузырьковой сортировки имеет сложность O(n^2), где n - количество элементов в исходном массиве.
Он неэффективен при работе с большими массивами и может быть улучшен за счет оптимизаций, таких как проверка на отсортированность массива 
или использование флага для прерывания сортировки при отсутствии обменов.
Алгоритм является устойчивым к повторяющимся элементам и подходит для сортировки малых массивов или уже частично отсортированных массивов.

===========Сортировка выбором===================
Алгоритм сортировки выбором (Selection Sort) работает следующим образом:

1. Проходим по массиву от начала до конца.
2. Находим минимальный элемент в оставшейся части массива.
3. Меняем его местами с первым элементом в оставшейся части массива.
4. Продолжаем проходить по массиву, начиная со второго элемента, пока не будет выполнено n-1 проходов, где n - количество элементов в массиве.
5. Результатом является отсортированный массив.

Алгоритм сортировки выбором имеет сложность O(n^2), где n - количество элементов в исходном массиве.
 Он также неэффективен при работе с большими массивами и может быть улучшен за счет оптимизаций, таких как проверка на отсортированность массива. 
Алгоритм является неустойчивым к повторяющимся элементам, но подходит для сортировки малых массивов или уже частично отсортированных массивов.

=========Сортировка вставками================
Алгоритм сортировки вставками (Insertion Sort) работает следующим образом:

1. Проходим по массиву от второго элемента до конца.
2. Сравниваем текущий элемент с предыдущим, если текущий элемент меньше предыдущего, то меняем их местами.
3. Повторяем шаг 2 для всех предыдущих элементов до тех пор, пока не найдем элемент, который меньше текущего или не дойдем до начала массива.
4. Переходим к следующему элементу и повторяем шаги 2-3 до конца массива.
5. Результатом является отсортированный массив.

Алгоритм сортировки вставками имеет сложность O(n^2), где n - количество элементов в исходном массиве. 
Он также может быть улучшен за счет оптимизаций, таких как использование бинарного поиска для нахождения места вставки элемента.
Алгоритм является устойчивым к повторяющимся элементам и хорошо подходит для сортировки малых массивов или уже частично отсортированных массивов.

=======Гномья сортировка==================
Алгоритм гномьей сортировки (Gnome Sort) работает следующим образом:

1. Устанавливаем переменную i в 1.
2. Если i равно 1, переходим к шагу 4.
3. Если текущий элемент меньше или равен предыдущему элементу, меняем их местами и уменьшаем i на 1.
4. Иначе увеличиваем i на 1.
5. Повторяем шаги 2-4 пока i не станет равным длине массива.
6. Результатом является отсортированный массив.

Алгоритм гномьей сортировки также имеет сложность O(n^2), но он более эффективен, чем сортировка вставками при работе с уже частично отсортированными массивами. 
Алгоритм также устойчив к повторяющимся элементам.